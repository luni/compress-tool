#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  find-duplicate-sha256.sh [OPTIONS] [DIRECTORY...]

Description:
  Recursively scans the provided directories (defaults to ".") for files
  generated by analyze-archive.sh (suffix ".sha256") and reports any SHA-256
  digests that appear more than once. Each duplicate lists the manifest file
  and the archived path associated with that digest so you can spot redundant
  content across archives quickly.

Options:
  -A, --identical-archives   Only report archives whose manifests are identical
                             (same set of files + hashes). Requires sha256sum.
  -D, --delete-identical     Delete redundant archives/manifests when using
                             --identical-archives. Keeps the first archive in
                             each identical group and removes the rest.
  -S, --skip-intra-manifest  Ignore hashes that appear more than once inside the
                             same manifest (only care about cross-archive dupes).
  -y, --yes                  Automatically answer "yes" to deletion prompts.
  -h, --help                 Show this help message.
EOF
}

die() {
  printf 'Error: %s\n' "$1" >&2
  exit 2
}

require_tool() {
  command -v "$1" >/dev/null 2>&1 || die "Required tool '$1' is not on PATH."
}

SEP=$'\x1F'
GROUP_SEP=$'\x1E'
IDENTICAL_ONLY=0
SKIP_INTRA_MANIFEST=0
DELETE_IDENTICAL=0
AUTO_CONFIRM=0

declare -A HASH_COUNTS=()
declare -A HASH_LOCATIONS=()
declare -A SIGNATURE_MANIFESTS=()
declare -A MANIFEST_ENTRY_COUNTS=()
declare -A HASH_MANIFEST_SEEN=()
declare -A HASH_UNIQUE_MANIFEST_COUNT=()

confirm_delete_targets() {
  local -a targets=("$@")
  if (( AUTO_CONFIRM )); then
    printf 'Auto-confirmed removal of the following %d item(s):\n' "${#targets[@]}"
    for path in "${targets[@]}"; do
      printf '  - %s\n' "$path"
    done
    return 0
  fi

  printf 'The following %d item(s) will be removed:\n' "${#targets[@]}"
  for path in "${targets[@]}"; do
    printf '  - %s\n' "$path"
  done
  printf 'Proceed? [y/N]: '
  local reply
  if ! read -r reply; then
    return 1
  fi
  case "${reply,,}" in
    y|yes)
      return 0
      ;;
    *)
      printf 'Skipping deletion.\n'
      return 1
      ;;
  esac
}

delete_redundant_manifest() {
  local manifest="$1"
  local -a targets=()
  if [[ -e "$manifest" ]]; then
    targets+=("$manifest")
  fi
  if [[ "$manifest" == *.sha256 ]]; then
    local archive="${manifest%.sha256}"
    if [[ -e "$archive" ]]; then
      targets+=("$archive")
    fi
  fi

  if [[ "${#targets[@]}" -eq 0 ]]; then
    printf 'warning: nothing to delete for %s (files missing)\n' "$manifest" >&2
    return
  fi

  if confirm_delete_targets "${targets[@]}"; then
    for path in "${targets[@]}"; do
      if rm -f -- "$path"; then
        printf 'Deleted %s\n' "$path"
      else
        printf 'Failed to delete %s\n' "$path" >&2
      fi
    done
  fi
}

record_entry() {
  local hash="$1" manifest="$2" entry="$3"
  HASH_COUNTS["$hash"]=$(( ${HASH_COUNTS["$hash"]:-0} + 1 ))
  if [[ -v HASH_LOCATIONS["$hash"] ]]; then
    HASH_LOCATIONS["$hash"]+=$'\n'"$manifest$SEP$entry"
  else
    HASH_LOCATIONS["$hash"]="$manifest$SEP$entry"
  fi
  local combination="$hash$GROUP_SEP$manifest"
  if [[ ! -v HASH_MANIFEST_SEEN["$combination"] ]]; then
    HASH_MANIFEST_SEEN["$combination"]=1
    HASH_UNIQUE_MANIFEST_COUNT["$hash"]=$(( ${HASH_UNIQUE_MANIFEST_COUNT["$hash"]:-0} + 1 ))
  fi
}

entries_recorded=0
lines_skipped=0

process_manifest() {
  local manifest="$1" line line_no=0 manifest_entries=0
  local -a manifest_pairs=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    line_no=$((line_no + 1))
    line="${line%$'\r'}"
    [[ -z "$line" ]] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    if [[ "$line" =~ ^([[:xdigit:]]{64})[[:space:]][[:space:]]+(.+)$ ]]; then
      record_entry "${BASH_REMATCH[1]}" "$manifest" "${BASH_REMATCH[2]}"
      manifest_pairs+=("${BASH_REMATCH[1]}$SEP${BASH_REMATCH[2]}")
      entries_recorded=$((entries_recorded + 1))
      manifest_entries=$((manifest_entries + 1))
    else
      lines_skipped=$((lines_skipped + 1))
      printf 'warning: %s:%d not recognized, skipping\n' "$manifest" "$line_no" >&2
    fi
  done <"$manifest"

  MANIFEST_ENTRY_COUNTS["$manifest"]=$manifest_entries

  if [[ "$manifest_entries" -eq 0 ]]; then
    printf 'note: %s contained no recognizable entries\n' "$manifest" >&2
  fi

  if (( IDENTICAL_ONLY )); then
    local signature
    if ((${#manifest_pairs[@]} > 0)); then
      signature="$(printf '%s\n' "${manifest_pairs[@]}" | LC_ALL=C sort | sha256sum | awk '{print $1}')"
    else
      signature="$(printf '' | sha256sum | awk '{print $1}')"
    fi
    if [[ -v SIGNATURE_MANIFESTS["$signature"] ]]; then
      SIGNATURE_MANIFESTS["$signature"]+="$GROUP_SEP$manifest"
    else
      SIGNATURE_MANIFESTS["$signature"]="$manifest"
    fi
  fi
}

dirs=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -A|--identical-archives)
      IDENTICAL_ONLY=1
      shift
      ;;
    -D|--delete-identical)
      DELETE_IDENTICAL=1
      shift
      ;;
    -S|--skip-intra-manifest)
      SKIP_INTRA_MANIFEST=1
      shift
      ;;
    -y|--yes)
      AUTO_CONFIRM=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      die "Unknown option: $1"
      ;;
    *)
      dirs+=("$1")
      shift
      ;;
  esac
done

if [[ $# -gt 0 ]]; then
  dirs+=("$@")
fi

if [[ "${#dirs[@]}" -eq 0 ]]; then
  dirs=(".")
fi

if (( DELETE_IDENTICAL && ! IDENTICAL_ONLY )); then
  die "--delete-identical requires --identical-archives"
fi

for dir in "${dirs[@]}"; do
  [[ -d "$dir" ]] || die "Directory not found: $dir"
done

if (( IDENTICAL_ONLY )); then
  require_tool sha256sum
fi

manifests_scanned=0
while IFS= read -r -d '' manifest; do
  manifests_scanned=$((manifests_scanned + 1))
  process_manifest "$manifest"
done < <(find "${dirs[@]}" -type f -name '*.sha256' -print0)

if [[ "$manifests_scanned" -eq 0 ]]; then
  die "No .sha256 manifests found under the provided directory set."
fi

printf 'Scanned %d manifest(s); %d total entries (%d unique hashes). Skipped %d line(s).\n' \
  "$manifests_scanned" "$entries_recorded" "${#HASH_COUNTS[@]}" "$lines_skipped"

if (( IDENTICAL_ONLY )); then
  identical_groups_found=0
  for signature in "${!SIGNATURE_MANIFESTS[@]}"; do
    IFS=$GROUP_SEP read -r -a manifests_in_group <<<"${SIGNATURE_MANIFESTS["$signature"]}"
    if ((${#manifests_in_group[@]} > 1)); then
      identical_groups_found=1
      mapfile -t manifests_in_group < <(printf '%s\n' "${manifests_in_group[@]}" | LC_ALL=C sort)
      entries="${MANIFEST_ENTRY_COUNTS["${manifests_in_group[0]}"]:-0}"
      printf '\nArchives with identical contents (%d entries):\n' "$entries"
      for manifest in "${manifests_in_group[@]}"; do
        printf '  - %s\n' "$manifest"
      done
      if (( DELETE_IDENTICAL )); then
        keeper="${manifests_in_group[0]}"
        printf 'Deleting redundant archives from this group (keeping %s)...\n' "$keeper"
        for manifest in "${manifests_in_group[@]:1}"; do
          delete_redundant_manifest "$manifest"
        done
      fi
    fi
  done

  if (( identical_groups_found == 0 )); then
    printf 'No archives with identical contents were found.\n'
  elif (( DELETE_IDENTICAL )); then
    printf '\nDeletion pass complete.\n'
  fi
  exit 0
fi

duplicate_hashes=()
for hash in "${!HASH_COUNTS[@]}"; do
  if (( SKIP_INTRA_MANIFEST )); then
    if (( ${HASH_UNIQUE_MANIFEST_COUNT["$hash"]:-0} > 1 )); then
      duplicate_hashes+=("$hash")
    fi
  else
    if (( HASH_COUNTS["$hash"] > 1 )); then
      duplicate_hashes+=("$hash")
    fi
  fi
done

if [[ "${#duplicate_hashes[@]}" -eq 0 ]]; then
  printf 'No duplicate SHA-256 entries found.\n'
  exit 0
fi

printf '\nDuplicate SHA-256 digests:\n'
IFS=$'\n' read -r -d '' -a duplicate_hashes < <(printf '%s\n' "${duplicate_hashes[@]}" | LC_ALL=C sort && printf '\0')

for hash in "${duplicate_hashes[@]}"; do
  display_count="${HASH_COUNTS["$hash"]}"
  if (( SKIP_INTRA_MANIFEST )); then
    display_count="${HASH_UNIQUE_MANIFEST_COUNT["$hash"]:-0}"
  fi
  printf '\nSHA256 %s (%d occurrences):\n' "$hash" "$display_count"
  printed_manifest_list=""
  while IFS= read -r location || [[ -n "$location" ]]; do
    IFS=$SEP read -r manifest entry <<<"$location"
    if (( SKIP_INTRA_MANIFEST )); then
      if [[ ":$printed_manifest_list:" == *":$manifest:"* ]]; then
        continue
      fi
      printed_manifest_list="${printed_manifest_list:+$printed_manifest_list:}$manifest"
    fi
    printf '  - %s :: %s\n' "$manifest" "$entry"
  done <<<"${HASH_LOCATIONS["$hash"]}"
done
